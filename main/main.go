package main

import (
	//	"flag"
	"log"
	"math/rand"

	"github.com/iotaledger/giota"
	"github.com/shufps/pidiver/pidiver"
	"github.com/shufps/pidiver/raspberry"
	flag "github.com/spf13/pflag"
)

const APP_VERSION = "0.1"

// The flag package provides a default help printer via -h switch
var configFile *string = flag.StringP("fpga.core", "f", "../pidiver1.1.rbf", "Core file to upload to FPGA")
var device *string = flag.StringP("usb.device", "d", "/dev/ttyACM0", "Device file for usb communication")
var diver *string = flag.StringP("pow.type", "t", "usbdiver", "'pidiver', 'usbdiver'")

func main() {
	flag.Parse() // Scan the arguments list

	config := pidiver.PiDiverConfig{
		Device:         *device,
		ConfigFile:     *configFile,
		ForceFlash:     false,
		ForceConfigure: false}

	var powFunc giota.PowFunc
	var err error
	if *diver == "usbdiver" {
		err = pidiver.InitUSBDiver(&config)
		powFunc = pidiver.PowUSBDiver
	} else {
		llStruct := raspberry.GetLowLevel()
		err = pidiver.InitPiDiver(&llStruct, &config)
		powFunc = pidiver.PowPiDiver
	}
	if err != nil {
		log.Fatal(err)
	}

	// test transaction data
	var transaction = []rune("999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999A9RGRKVGWMWMKOLVMDFWJUHNUNYWZTJADGGPZGXNLERLXYWJE9WQHWWBMCPZMVVMJUMWWBLZLNMLDCGDJ999999999999999999999999999999999999999999999999999999YGYQIVD99999999999999999999TXEFLKNPJRBYZPORHZU9CEMFIFVVQBUSTDGSJCZMBTZCDTTJVUFPTCCVHHORPMGCURKTH9VGJIXUQJVHK999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999")
	mwm := 14
	for i := 0; i < 10000; i++ {
		for j := 0; j < 256; j++ {
			transaction[j] = rune(pidiver.TRYTE_CHARS[rand.Intn(len(pidiver.TRYTE_CHARS))])
		}
		var ret giota.Trytes
		var err error

		ret, err = powFunc(giota.Trytes(string(transaction)), mwm)
		if err != nil {
			log.Fatalf("Error: %g", err)
		}
		log.Printf("Nonce-Trytes: %s\n", ret)
		// verify result ... copy nonce to transaction
		copy(transaction[giota.NonceTrinaryOffset/3:], []rune(string(ret)))
		hash := giota.Trytes(string(transaction)).Hash()
		log.Printf("hash: %s\n\n", hash)
		tritsHash := hash.Trits()
		for i := 0; i < mwm; i++ {
			if tritsHash[len(tritsHash)-1-i] != 0 {
				log.Fatalf("verify error at %d!\n", i)
			}
		}
	}

}
